# 基础知识

## 引言

略。


## 程序

ISO的C++标准定义了两种实体：
1. 核心语言特性（core language feature）。如：内置类型（char、int）、循环控制（for语句、while语句）；
2. 标准库组件（standard library component）。如：容器（vector、map）、I/O操作（<<、getline()）。

C\+\+标准库可以用C++语言本身实现，仅在实现线程上下文这样的功能时才使用少量的机器代码。

C\+\+是一种静态语言，也就意味着在使用任何实体（如：对象、值、名称和表达式）时，编译器都必须清楚该实体的类型。对象的类型决定了能够在该对象上执行的操作。


## Hello, World!

来自main()的非零值表示程序失败，并非每个操作系统和操作环境都会用到这个返回值。一般来说，基于Linux/Unix的环境通常会用到，而基于Windows的环境一般不会用到。

对于`std::cout`，符号`std::`负责指定名字`cout`所在标准库的命令空间。


## 函数

实参传递的过程和拷贝初始化非常相似。

如果存在两个可供选择的函数并且他们难分优劣，则编译器认为此次调用具有二义性并报错。

函数重载是泛型编程的一个关键问题。如果函数重载了，则所有重载的同名函数应该实现相同的语义内容。


## 类型、变量和算术运算

- `+x`  // 一元加法
- `-x`  // 一元减法 

表达式中使用的类型转换称为**常用算术类型转换**（usual arithmetic conversion），它的目的是确保表达式以它的运算对象中最高的精度进行求值计算。如：一个double值和一个int值求和，执行的是双精度浮点数的加法。

变量初始化的几种方法：
- `double d1 = 2.3;`  // 传统的C方法
- `double d2 {2.3}`  // 新式的C++方法，不会做隐式类型转换
- `double d2 = {2.3}`  // 使用{...}方式时，等号是可选的

注：使用新式的C++变量初始化方法可以确保在隐式类型转换中不会导致信息丢失。

**窄化类型转换**（narrowing conversion）是指类似将double转换成int这种，它虽然会丢失一些信息，但是C++编译器并不禁止这种转换，反而会隐式地自动执行。

用户定义的类型（如：string、vector、Matrix、Motor_controller和Orc_warrior）可以在定义时进行隐式初始化。

为了避免在初始化时发生类型转换，可以使用**auto**的方式进行初始化。如：
```cpp
auto d = 1.2;
```
说明：使用auto可以帮助我们避免冗余，并且无需再书写长类型名称。


## 作用域和生命周期

几种作用域：
1. 局部作用域（local scope），从定义处开始到语句块结束。
2. 类作用域（class scope），在整个类中生效。
3. 命令空间作用域（namespace scope），从定义处开始到命名空间结束。


## 常量

C++支持两种不变性概念：
1. **const**，表示“我承诺不改变这个值”。**主要用于说明接口**，这样在把变量传入函数时就不必担心变量会在函数内被改变了。编译器负责确认并执行const的承诺。
2. **constexpr**，表示“在编译时求值”。**主要用于说明常量**，作用是允许把数据置于只读内存中以及提升性能。

如果某个函数被用在**常量表达式**（constant expression）中，即该表达式在编译时求值，则这个函数必须定义成constexpr。如：
```cpp
constexpr double square(double x) {
    return x * x;
}
const int dmv = 1.7;
constexpr double max = 1.4 * square(dmv);
```

说明：
1. 要想定义成constexpr，函数必须非常简单，即：函数中仅有一条计算某个值的return语句。
2. 编译时求值对程序的性能非常重要，所以需要使用常量。
3. 对于constexpr声明的函数，也可以当作普通函数来使用，只要使用非常量实参来调用这个函数就可以了。


## 指针、数组和引用

数组的大小必须是一个常量表达式。

C++提供了一个简单的for语句形式，即：**范围for语句**（range-for），其可以用最简单的方式遍历一个序列。如：
```cpp
int v[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
for (auto x : v) {
    cout << x << '\n';
}
```
```cpp
for (auto x : {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) {
    cout << x << '\n';
}
```

以上的range-for语句表示：对于v中的每个元素，从头到尾依次拷入x并进行处理。

如果需要使用引用的方式，则可以使用如下形式：
```cpp
int v[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
for (auto &x : v) {
    cout << x << '\n';
}
```

对于函数调用时的参数传递形式，主要有一下两种：
1. 值传递；
2. 引用传递；

我们都知道，值传递会引入拷贝的开销，而引用传递能够修改实参的值。如果既不想引入拷贝的开销，又不想实参被改变的话，可以使用**const引用**。示例如下：
```cpp
double sum(const vector<double> &>;
```

关于空指针：
1. C语言中，0和NULL都是整数，用来表示空指针的值。
2. C++中，可以使用**nullptr**来代替0和NULL，且能够避免混淆指针值（nullptr）和整数值（0或NULL）。
3. `while (p)`等同于`while (p != nullptr)`。


## 检验

略。


## 建议

1. 要关注编程技术，而非语言特性。
2. 函数重载的使用情况是，几个函数的任务相同而处理的类型不同。
3. 如果一个函数可能需要在编译时求值，那么把它声明成constexpr。
4. 别使用“魔法常量”，尽量使用符号化的常量。
5. 当指明了类型名字时，建议在声明语句中使用`{}`形式的初始值列表。
6. 当使用auto关键字时，建议在声明语句中使用`=`进行初始化。
7. 建议使用nullptr，别再使用0和NULL了。
8. 如果还不打算初始化一个变量，那就先别声明它。

